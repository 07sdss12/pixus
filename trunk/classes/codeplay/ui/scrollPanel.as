// scrollPanel class// 2009-03-04// (cc)2007-2009 codeplay// By Jam Zhang// jam@01media.cn/*Referencepublic function scrollPanel(data:Object=null):voidoptions.viewWidth:int=300						Setting the viewport width. The default value is 300.options.viewHeight:int=300						Setting the viewport height. The default value is 300.options.manualContentSize:boolean=false			When true, scrollPanel will automatically detect the content size using getBounds(this). When false, the content size is set by set contentSize(b:Rectangle).options.vScrolling:Boolean=true					Indicates whether there will be a verticcal scroll bar.options.hScrolling:Boolean=true					Indicates whether there will be a horizontal scroll bar.options.vScrollBar:scrollBar=null				Assigning an external vertical scroll bar instead of generating a new one.options.hScrollBar:scrollBar=null				Assigning an external horizontal scroll bar instead of generating a new one.options.vScrollOffsetX:int=0					The X offset of the vertical scroll bar. By default the vertical scroll bar is located inside the viewport by the right edge with a margin.options.hScrollOffsetY:int=0					The Y offset of the horizontal scroll bar. By default the horizontal scroll bar is displayed inside the viewport by the bottom edge with a margin.options.vScrollOffsetRailLength:int=0			The offset of the length of vertical the scroll bar rail. By default the vertical scroll bar rail is of the identical width of the viewport.options.hScrollOffsetRailLength:int=0			The offset of the length of horizontal the scroll bar rail. By default the horizontal scroll bar rail is of the identical width of the viewport.options.minBarLength:int=100					Minimal length of the scrollBar.options.delta:int=10							The incremental value of each mouse scroll. And when options.snapping is true, dragging of the scroll bar will be quantized by options.delta.options.snapping:Boolean=false					When options.snapping is true, dragging of the scroll bar will be quantized by options.delta.options.stageResponding:Boolean=false			Indicates whether the stage shall respond to MOUSE_WHEEL and Dragging actions just as performed to the scrollPanel instance itself.options.mask:Boolean=true						Indicates whether a mask will be generated to crop the edge of the scrollPanel instance.options.scrollAlign:Object=null					Default scroll bar align mode if vScrollAlign or hScrollAlign is absent.options.vScrollAlign:Object=null				Vertical scroll bar align mode.options.hScrollAlign:Object=null				Horizontal scroll bar align mode.options.inertia:Boolean=true					Indicates whether scrolling and dragging have the inertia effect.Mouse Wheel Response	MOUSE_WHEEL without modification key will scroll the vertical scroll bar.	MOUSE_WHEEL with Shift, Alt, Control or Command key will scroll the horizontal scroll bar. Control and Command key are only supported by Adobe AIR.*/package codeplay.ui{	import caurina.transitions.Tweener;		import codeplay.display.codeplaySprite;	import codeplay.event.customEvent;	import codeplay.physics.speed;	import codeplay.utils.codeplayShared;		import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.geom.Rectangle;	public class scrollPanel extends codeplaySprite {		// Scroll Panel Attributes		var viewWidth:int=300;		var viewHeight:int=300;		var vScrolling:Boolean=true;		var hScrolling:Boolean=true;		var vScrollBar:scrollBar=null;		var hScrollBar:scrollBar=null;		var vScrollBarExternal:scrollBar=null;		var hScrollBarExternal:scrollBar=null;		var manualContentSize:Boolean=false;		var _contentSize:Rectangle;		private var dragOrigin:Point;		private var dragging,vDragging,hDragging:Boolean;		// Offset Values		var vScrollOffsetX:int=0;		var vScrollOffsetY:int=0;		var vScrollOffsetRailLength:int=0;		var hScrollOffsetX:int=0;		var hScrollOffsetY:int=0;		var hScrollOffsetRailLength:int=0;		var panelMask:Sprite=null;		// Scroll Bar Attributes		public var scrollDelta:int=10;		public var snapping:Boolean=false;		public var stageResponding:Boolean=false;		public var masked:Boolean=false;		public var vInertiaSpeed,hInertiaSpeed:Number;		var vScrollAlign:Object=null;		var hScrollAlign:Object=null;		var minBarLength:int=100;		var inertia:Boolean=true;		var vSpeed, hSpeed:speed;		// Constructor		public function scrollPanel(options:Object=null):void {			if (options!=null) {				if (options.width!=undefined) {					viewWidth=options.viewWidth;				}				if (options.viewHeight!=undefined) {					viewHeight=options.viewHeight;				}				if (options.manualContentSize!=undefined) {					manualContentSize=options.manualContentSize;				}				// Scroll Bars				if (options.vScrolling!=undefined) {					vScrolling=options.vScrolling;				}				if (options.hScrolling!=undefined) {					hScrolling=options.hScrolling;				}				if (options.vScrollBar!=undefined) {					vScrollBarExternal=options.vScrollBar;				}				if (options.hScrollBar!=undefined) {					hScrollBarExternal=options.hScrollBar;				}				if(options.minBarLength!=undefined)					minBarLength=options.minBarLength;				// Offset Values				if (options.vScrollOffsetX!=undefined) {					vScrollOffsetX=options.vScrollOffsetX;				}				if (options.vScrollOffsetY!=undefined) {					vScrollOffsetY=options.vScrollOffsetY;				}				if (options.vScrollOffsetRailLength!=undefined) {					vScrollOffsetRailLength=options.vScrollOffsetRailLength;				}				if (options.hScrollOffsetY!=undefined) {					hScrollOffsetY=options.hScrollOffsetY;				}				if (options.hScrollOffsetY!=undefined) {					hScrollOffsetY=options.hScrollOffsetY;				}				if (options.hScrollOffsetRailLength!=undefined) {					hScrollOffsetRailLength=options.hScrollOffsetRailLength;				}				// Scrolling Control				if (options.delta!=undefined) {					scrollDelta=options.delta;				}				if (options.snapping!=undefined) {					snapping=options.snapping;				}				if (options.stageResponding!=undefined) {					stageResponding=options.stageResponding;				}				if (options.vScrollAlign==undefined)					options.vScrollAlign=options.scrollAlign;				if (options.hScrollAlign==undefined)					options.hScrollAlign=options.scrollAlign;				if (options.vScrollAlign!=undefined)					vScrollAlign=options.vScrollAlign;				if (options.hScrollAlign!=undefined)					hScrollAlign=options.hScrollAlign;				if(options.inertia!=undefined)					inertia=options.inertia;				// Mask				if (options.mask!=undefined) {					masked=options.mask;				}			}			addEventListener(Event.ADDED_TO_STAGE,init);			addEventListener(Event.REMOVED_FROM_STAGE,dispose);		}		// Initializing		function init(event:Event):void {			removeEventListener(Event.ADDED_TO_STAGE,init);			_contentSize=getBounds(this);			if(stageResponding){				stage.addEventListener(MouseEvent.MOUSE_WHEEL,handleMouse);				stage.addEventListener(MouseEvent.MOUSE_DOWN,handleMouse);			}			if(vScrolling||hScrolling){				addEventListener(MouseEvent.MOUSE_WHEEL,handleMouse);				addEventListener(MouseEvent.MOUSE_DOWN,handleMouse);			}			// Adding mask			if(masked){				panelMask=new Sprite();				panelMask.graphics.beginFill(0x000000);				panelMask.graphics.drawRect(0,0,viewWidth-2,viewHeight);				panelMask.graphics.endFill();				panelMask.x=1;				parent.addChild(panelMask);				mask=panelMask;			}			// Adding scrollbars			parent.addEventListener(customEvent.RESIZE,handleResize);			parent.addEventListener(customEvent.CONTENT_RESIZED,handleResize);			if(vScrolling){				addVScrollBar();			}			if(hScrolling){				addHScrollBar();			}		}		// Disposing		function dispose(event:Event):void {			if(masked){				parent.removeChild(panelMask);				panelMask=null;			}			if(vScrolling){				if(vScrollBarExternal!=null)					vScrollBarExternal.visible=false;				else					parent.removeChild(vScrollBar);				vScrollBar.removeEventListener(customEvent.SCROLLING,handleScroll);				vScrollBar.removeEventListener(customEvent.SCROLLED,handleScroll);				vScrollBar.removeEventListener(customEvent.SCROLLBAR_GRIPPED,handleScroll);				vScrollBar=null;			}			if(hScrolling){				if(hScrollBarExternal!=null)					hScrollBarExternal.visible=false;				else					parent.removeChild(hScrollBar);				hScrollBar.removeEventListener(customEvent.SCROLLED,handleScroll);				hScrollBar.removeEventListener(customEvent.SCROLLED,handleScroll);				hScrollBar.removeEventListener(customEvent.SCROLLBAR_GRIPPED,handleScroll);				hScrollBar=null;			}			if(vScrolling||hScrolling){				removeEventListener(MouseEvent.MOUSE_WHEEL,handleMouse);				removeEventListener(MouseEvent.MOUSE_DOWN,handleMouse);			}			if(stageResponding){				stage.removeEventListener(MouseEvent.MOUSE_WHEEL,handleMouse);				stage.removeEventListener(MouseEvent.MOUSE_DOWN,handleMouse);			}		}		// Resize Logic		public function resizeView(w:Object=null, h:Object=null){			if (w!=null){				viewWidth=int(w);				if(viewWidth>contentWidth+x)					x=Math.min(0,viewWidth-contentWidth);			}			if (h!=null){				viewHeight=int(h);				if(viewHeight>contentHeight+x)					y=Math.min(0,viewHeight-contentHeight);			}			if(masked){				panelMask.width=viewWidth;				panelMask.height=viewHeight;			}			syncScrollBars();		}		function syncScrollBars(){			if(vScrolling){				vScrollBar.visible=(viewHeight<contentHeight);				if (vScrollBar.visible) {					vScrollBar.setX(viewWidth-scrollBar.DEFAULT_BAR_THICKNESS+vScrollOffsetX);					vScrollBar.barLength=Math.round(viewHeight*viewHeight/contentHeight);					vScrollBar.railLength=viewHeight+vScrollOffsetRailLength;					syncVScrollBar();				}			}			if(hScrolling){				hScrollBar.visible=(viewWidth<contentWidth);				if (hScrollBar.visible) {					hScrollBar.setY(viewHeight-scrollBar.DEFAULT_BAR_THICKNESS+hScrollOffsetY);					hScrollBar.barLength=Math.round(viewWidth*viewWidth/contentWidth);					hScrollBar.railLength=viewWidth+hScrollOffsetRailLength;					syncHScrollBar();				}			}		}		// Visibility		function addVScrollBar():void{			if(vScrollBarExternal!=null){				vScrollBar=vScrollBarExternal;				vScrollBarExternal.visible=false;			} else {				vScrollBar=new scrollBar({					x:viewWidth-scrollBar.DEFAULT_BAR_THICKNESS+vScrollOffsetX,					align:vScrollAlign,					inertia:inertia,					minBarLength:minBarLength				});				parent.addChild(vScrollBar);				parent.setChildIndex(vScrollBar,parent.numChildren-1);			}			vScrollBar.addEventListener(customEvent.SCROLLING,handleScroll);			vScrollBar.addEventListener(customEvent.SCROLLED,handleScroll);			vScrollBar.addEventListener(customEvent.SCROLLBAR_GRIPPED,handleScroll);		}		function addHScrollBar():void{			if(hScrollBarExternal!=null){				hScrollBar=hScrollBarExternal;				hScrollBarExternal.visible=false;			} else {				hScrollBar=new scrollBar({					y:viewHeight-scrollBar.DEFAULT_BAR_THICKNESS+hScrollOffsetY,					vertical:false,					align:hScrollAlign,					inertia:inertia,					minBarLength:minBarLength				});				parent.addChild(hScrollBar);				parent.setChildIndex(hScrollBar,parent.numChildren-1);			}			hScrollBar.addEventListener(customEvent.SCROLLING,handleScroll);			hScrollBar.addEventListener(customEvent.SCROLLED,handleScroll);			hScrollBar.addEventListener(customEvent.SCROLLBAR_GRIPPED,handleScroll);		}		public function set vScrollVisible(v:Boolean){			vScrolling=v;			if(vScrolling&&vScrollBar==null){				addVScrollBar();			} else if(!vScrolling&&vScrollBar!=null){				parent.removeChild(vScrollBar);				vScrollBar=null;			}		}		public function set hScrollVisible(v:Boolean):void{			hScrolling=v;			if(hScrolling&&hScrollBar==null){				addHScrollBar();			} else if(!hScrolling&&hScrollBar!=null){				parent.removeChild(hScrollBar);				hScrollBar=null;			}		}		// Size and Movement		public function set contentSize(b:Rectangle):void{			_contentSize=b;			syncScrollBars();		}		function get contentWidth():int{			if(!manualContentSize)				_contentSize=getBounds(this);			return _contentSize.x+_contentSize.width;		}		function get contentHeight():int{			if(!manualContentSize)				_contentSize=getBounds(this);			return _contentSize.y+_contentSize.height;		}		function legalX(x1:int):int{			return Math.min(0,Math.max(viewWidth-contentWidth,x1));		}		function legalY(y1:int):int{			return Math.min(0,Math.max(viewHeight-contentHeight,y1));		}		function setX(x1:int):int{			x=legalX(x1);			syncHScrollBar();			return x;		}		function setY(y1:int):int{			y=legalY(y1);			syncVScrollBar();			return y;		}		function syncVScrollBar():void{			vScrollBar.percentage=-y/(contentHeight-viewHeight);		}		function syncHScrollBar():void{			hScrollBar.percentage=-x/(contentWidth-viewWidth);		}		// Physics		public function stopInertia():void{			stopScrollBarInertia();			stopDraggingInertia();		}		function stopDraggingInertia():void{			Tweener.removeTweens(this,vInertiaSpeed,hInertiaSpeed);		}		function stopScrollBarInertia():void{			if(inertia){				if(hScrolling)					hScrollBar.stopInertia();				if(vScrolling)					vScrollBar.stopInertia();			}		}		// Event Handlers		function handleScroll(e:customEvent):void {			switch (e.type) {				case customEvent.SCROLLBAR_GRIPPED :					stopDraggingInertia();					break;				case customEvent.SCROLLING :					// Dispatched by scrollBar					if(e.data.vertical)						y=Math.round((viewHeight-contentHeight)*e.data.percentage);					else {						x=Math.round((viewWidth-contentWidth)*e.data.percentage);					}					break;				case customEvent.SCROLLED :					// Dispatched by scrollBar					if(e.data.vertical){						y=Math.round((viewHeight-contentHeight)*e.data.percentage);						if (snapping) {							var y1:int=Math.round(y/scrollDelta)*scrollDelta;							Tweener.addTween(this,{y:y1,time:codeplayShared.UI_TWEENING_TIME,transition:'easeOutCubic'});							syncVScrollBar();						}					} else {						x=Math.round((viewWidth-contentWidth)*e.data.percentage);						if (snapping) {							var x1:int=Math.round(x/scrollDelta)*scrollDelta;							Tweener.addTween(this,{x:x1,time:codeplayShared.UI_TWEENING_TIME,transition:'easeOutCubic'});							syncHScrollBar();						}					}					break;			}		}		function handleMouse(e:MouseEvent):void {			switch(e.type){				// Mouse Wheel Response				case MouseEvent.MOUSE_WHEEL:					// Mouse wheel works slower naturally under Mac OS. To correct it.					if(codeplay.utils.Compatibilities.isMacOS)						e.delta*=codeplay.utils.Compatibilities.MAC_MOUSE_WHEEL_SPEED_RATE;					// var keyboardModification:Boolean=e.shiftKey||e.altKey||e.controlKey||e.commandKey; // AIR Compatible					var keyboardModification:Boolean=e.shiftKey||e.altKey; // Flash doesn't support detection of controlKey and commandKey					if(vScrolling&&!keyboardModification){						var y1:int=legalY(y+scrollDelta*e.delta);						syncVScrollBar();						Tweener.addTween(this,{y:y1,time:codeplayShared.UI_TWEENING_TIME,transition:'easeOutCubic'});					} else if(hScrolling&&keyboardModification){						var x1:int=legalX(x+scrollDelta*e.delta);						syncHScrollBar();						Tweener.addTween(this,{x:x1,time:codeplayShared.UI_TWEENING_TIME,transition:'easeOutCubic'});					}					break;				// Begin Dragging				case MouseEvent.MOUSE_DOWN:					if((vScrolling||hScrolling)&&parent.mouseX>0&&parent.mouseX<viewWidth&&parent.mouseY>0&&parent.mouseY<viewHeight){						// Stop Scroll Bar Inertia First						stopInertia();						// Hold On for Direction Detection						dragging=false;						dragOrigin=new Point(parent.mouseX,parent.mouseY);						addEventListener(MouseEvent.MOUSE_MOVE,handleMouse);						addEventListener(MouseEvent.MOUSE_UP,handleMouse);						if(stageResponding){							stage.addEventListener(MouseEvent.MOUSE_MOVE,handleMouse);							stage.addEventListener(MouseEvent.MOUSE_UP,handleMouse);						}					}					break;				// During Dragging				case MouseEvent.MOUSE_MOVE:					if(dragging){						if(vScrolling&&vDragging){							syncVScrollBar();							if(inertia)								vSpeed.value=y;						}						if(hScrolling&&hDragging){							syncHScrollBar();							if(inertia)								hSpeed.value=x;						}					} else {						// Initial movement will not drag the content but be used to detect the direction and lock the movement in certain axises.						var dX:int=Math.abs(parent.mouseX-dragOrigin.x);						var dY:int=Math.abs(parent.mouseY-dragOrigin.y);						if(Math.sqrt(Math.pow(dX,2)+Math.pow(dY,2))>=codeplayShared.DRAG_INITIAL_DISTANCE){							vDragging=(dY>dX*.5);							hDragging=(dX>dY*.5);							dragging=true;							// Calculating the Dragging Rectangle							var r:Rectangle=new Rectangle(x,y,0,0);							if(vScrolling&&vDragging){								if(inertia)									vSpeed=new speed(y);								r.height=Math.max(0,contentHeight-viewHeight);								r.y=-r.height;							}							if(hScrolling&&hDragging){								if(inertia)									hSpeed=new speed(x);								r.width=Math.max(0,contentWidth-viewWidth);								r.x=-r.width;							}							if(r.width>0||r.height>0)								codeplayStartDrag(false,r);						}					}					break;				// Finish Dragging				case MouseEvent.MOUSE_UP:					removeEventListener(MouseEvent.MOUSE_MOVE,handleMouse);					removeEventListener(MouseEvent.MOUSE_UP,handleMouse);					if(vScrolling&&inertia&&vDragging&&dragging){						vInertiaSpeed=vSpeed.currentSpeed;						Tweener.addTween(this,{							vInertiaSpeed:0,							time:codeplayShared.UI_INERTIA_TIME,							onUpdate:function():void{setY(y+vInertiaSpeed)}						});						vSpeed=null;					}					if(hScrolling&&inertia&&hDragging&&dragging){						hInertiaSpeed=hSpeed.currentSpeed;						Tweener.addTween(this,{							hInertiaSpeed:0,							time:codeplayShared.UI_INERTIA_TIME,							onUpdate:function():void{setX(x+hInertiaSpeed)}						});						hSpeed=null;					}					if(stageResponding){						stage.removeEventListener(MouseEvent.MOUSE_MOVE,handleMouse);						stage.removeEventListener(MouseEvent.MOUSE_UP,handleMouse);					}					break;			}		}		function handleResize(e:customEvent):void {			if (e.data!=null) {				resizeView(e.data.viewWidth,e.data.viewHeight);			}		}	}}